import { useReducer, useState, useCallback } from 'react';
import { GeneratedData, GeneratorState, GeneratorAction, ApiError, ContentError, PdfGenerationError, ImageSelection, AnalysisData, UserTier } from '../types';
import { generatePdf } from '../services/pdfService';
import { generateFreeActivityData, generateAnalysisData, assembleFinalData } from '../services/activityService';
import { PDF_CONFIG, UI_CONFIG, USER_TIERS } from '../config';

const initialState: GeneratorState = {
  phase: 'input',
  loadingProgress: {},
  finalData: null,
  analysisData: null,
  error: null,
};

const generatorReducer = (state: GeneratorState, action: GeneratorAction): GeneratorState => {
  switch (action.type) {
    case 'GENERATE_START':
    case 'FINALIZE_START':
      return {
        ...state,
        loadingProgress: { 'Initializer': 'Starting generation...' },
        error: null,
      };
    case 'UPDATE_PROGRESS':
      return {
        ...state,
        loadingProgress: {
          ...state.loadingProgress,
          [action.payload.stage]: action.payload.message,
        },
      };
    case 'CLEAR_PROGRESS':
      return {
        ...state,
        loadingProgress: {},
      };
    case 'ANALYSIS_SUCCESS':
      return {
        ...state,
        phase: 'selecting-images',
        analysisData: action.payload,
        loadingProgress: {},
        error: null,
      }
    case 'GENERATE_SUCCESS':
        return {
            ...state,
            phase: 'final',
            finalData: action.payload,
            analysisData: null,
            loadingProgress: {},
            error: null,
        }
    case 'GENERATE_ERROR':
      return {
        ...state,
        phase: 'input',
        loadingProgress: {},
        analysisData: null,
        error: action.payload,
      };
    case 'UPDATE_SUMMARY':
        if (!state.finalData) return state;
        return {
            ...state,
            finalData: {
                ...state.finalData,
                summary: action.payload,
            },
        };
    case 'RESET':
      return {
          ...initialState,
      };
    default:
      return state;
  }
};

interface ActivityGeneratorProps {
    tier: UserTier;
}

export const useActivityGenerator = ({ tier }: ActivityGeneratorProps) => {
  const [state, dispatch] = useReducer(generatorReducer, initialState);
  const [articleText, setArticleText] = useState<string>('');
  const [showSolutions, setShowSolutions] = useState<boolean>(false);
  const [gradeLevel, setGradeLevel] = useState<string>(UI_CONFIG.GRADE_LEVELS[1].value); // Default to 6th
  const [wordCount, setWordCount] = useState<number>(UI_CONFIG.WORD_COUNTS[1].value); // Default to 15

  const tierConfig = USER_TIERS[tier];

  const handleGenerate = useCallback(async () => {
    if (!articleText.trim()) {
      dispatch({ type: 'GENERATE_ERROR', payload: 'Please paste an article first.' });
      return;
    }
    dispatch({ type: 'GENERATE_START' });

    const updateProgress = (stage: string, message: string) => dispatch({ type: 'UPDATE_PROGRESS', payload: { stage, message } });
    const generationOptions = { gradeLevel, wordCount };

    try {
      if (tierConfig.permissions.isAutoGenerated) { // Free Tier
          const finalData = await generateFreeActivityData(articleText, generationOptions, updateProgress);
          dispatch({ type: 'GENERATE_SUCCESS', payload: finalData });
      } else { // Monthly & Yearly Tiers
          const analysisData = await generateAnalysisData(articleText, generationOptions, updateProgress);
          dispatch({ type: 'ANALYSIS_SUCCESS', payload: analysisData });
      }
    } catch (err) {
      console.error(err);
      let errorMessage = 'An unexpected error occurred. Please try again.';
       if (err instanceof ContentError) {
          errorMessage = err.message;
      } else if (err instanceof ApiError) {
          const reason = (err.cause as any)?.message;
          errorMessage = `The AI service failed to process the request. Please check the article text and try again. ${reason ? `Reason: ${reason}`: ''}`;
      }
      dispatch({ type: 'GENERATE_ERROR', payload: errorMessage });
    }
  }, [articleText, gradeLevel, wordCount, tierConfig]);

  const handleFinalize = useCallback(async (selections: ImageSelection) => {
    if (!state.analysisData || !selections.one || !selections.two) {
      dispatch({ type: 'GENERATE_ERROR', payload: 'Image selections are missing.' });
      return;
    }
    dispatch({ type: 'FINALIZE_START' });
    const updateProgress = (stage: string, message: string) => dispatch({ type: 'UPDATE_PROGRESS', payload: { stage, message } });

    try {
        const generationOptions = { gradeLevel, wordCount };
        const finalData = assembleFinalData(
            state.analysisData,
            selections,
            generationOptions,
            updateProgress
        );
        dispatch({ type: 'GENERATE_SUCCESS', payload: finalData });
    } catch (err) {
        console.error("Error finalizing activity:", err);
        dispatch({ type: 'GENERATE_ERROR', payload: 'Failed to assemble the activity sheet. Please try again.' });
    }
  }, [state.analysisData, gradeLevel, wordCount]);

  const handleDownloadPdf = useCallback(async () => {
    if (state.phase !== 'final' || !state.finalData) return;

    const wordCount = state.finalData.summary.split(/\s+/).filter(Boolean).length;
    if (wordCount < PDF_CONFIG.MIN_WORD_COUNT_WARNING) {
        const userConfirmed = window.confirm(
            `Warning: The summary has only ${wordCount} words. A minimum of ${PDF_CONFIG.MIN_WORD_COUNT_WARNING} is recommended for good formatting.\n\nDo you want to generate the PDF anyway?`
        );
        if (!userConfirmed) {
            return; // User cancelled, so we stop here.
        }
    }

    const updatePdfProgress = (message: string) => dispatch({ type: 'UPDATE_PROGRESS', payload: { stage: 'PDF Generation', message } });
    updatePdfProgress('Starting...');
    
    try {
      await generatePdf(state.finalData, tier, updatePdfProgress);
      updatePdfProgress('Success!');
    } catch (err) {
      console.error("PDF Generation failed", err);
      let errorMessage = "Sorry, there was an error creating the PDF.";
      if (err instanceof PdfGenerationError) {
          errorMessage = err.message;
      }
      updatePdfProgress('Failed!');
      alert(errorMessage);
    } finally {
        setTimeout(() => {
            dispatch({ type: 'CLEAR_PROGRESS' });
        }, 3000);
    }
  }, [state.finalData, state.phase, tier]);
  
  const handleSummaryChange = useCallback((newSummary: string) => {
      dispatch({ type: 'UPDATE_SUMMARY', payload: newSummary });
  }, []);

  const handleReset = useCallback(() => {
      dispatch({ type: 'RESET' });
      setArticleText('');
      setShowSolutions(false);
      setGradeLevel(UI_CONFIG.GRADE_LEVELS[1].value);
      setWordCount(UI_CONFIG.WORD_COUNTS[1].value);
  }, []);

  return {
    state,
    articleText,
    setArticleText,
    showSolutions,
    toggleSolutions: () => setShowSolutions(prev => !prev),
    gradeLevel,
    setGradeLevel,
    wordCount,
    setWordCount,
    handleGenerate,
    handleFinalize,
    handleDownloadPdf,
    handleReset,
    handleSummaryChange,
  };
};